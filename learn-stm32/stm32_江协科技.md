# 江协科技stm32教程
**本笔记从[5-1]EXTI外部（p12）开始记录，前面部分参见PPT（STM32入门教程.pptx，此PPT也是后续笔记的辅助文件）以及GoodNotes中STM32笔记本中的笔记（这个笔记本作为随手记录使用）。**
**2024/1/2 15:06 第一次记录**

---

## [5-1]EXTI外部中断

1. 主程序跳转到中断程序的过程是由**硬件电路**自动执行的。

![image-20240102171910957](stm32_江协科技.assets\image-20240102171910957.png)

- 中断执行前会对现场进行保护，C语言编程，编译器会自动做好保存和恢复工作。

- 中断跳转由于硬件的限制，只能跳转到固定的地址执行程序，为了能让硬件跳转到一个不固定的中断函数里，就需要在内存中定义一个地址的列表，列表地址是固定的，中断发生后，就跳到这个固定位置，然后再这个固定位置，由编译器加上一条跳转到中断函数的代码，这样中断函数就可以跳转到任意位置了，这个中断地址的列表，就叫**中断向量表**，相当于中断跳转的跳板。用C语言编程不需要管中断向量表，编译器帮我们做好了。

- 优先级数字越小，优先级越高，0是最高优先级。

- 外部中断有个功能：从低功耗模式的停止模式下唤醒STM32，如电源从电压过低恢复时，需要PVD借助外部中断退出停止模式；对于RTC闹钟，有时为了省电，RTC定了一个闹钟后，STM32会进入停止模式，等到闹钟响的时候再唤醒，这也需要借助外部中断，还有USB唤醒、以太网唤醒，也都是类似的作用。

![image-20240102174535465](stm32_江协科技.assets\image-20240102174535465.png)

- 到底什么样的设备需要外部中断呢？使用外部中断有什么好处呢？使用外部中断模块的特性：对于STM32来说，想要获取的信号是外部驱动的（STM32只能被动接收）很快的突发信号，如旋转编码器的输出信号；红外遥控接收头的输出；按键（不建议采用外部中断方式读取，不易处理按键抖动和松手检测的问题，按键的输出波形也不是转瞬即逝，如果不想用主循环读取得话，可以考虑定时器中断读取方式）。

## [5-2]对射式红外传感器计次&旋转编码器计次

- 只需要把外部中断从GPIO到NVIC出现的外设模块都配置好即可。
- **EXTI和NVIC不需要开启时钟。**RCC管理的都是内核外的外设，NVIC处于内核中所以管不到。
- AFIO的库函数和GPIO是一起的：

![image-20240102193755051](stm32_江协科技.assets\image-20240102193755051.png)

![image-20240102194855903](stm32_江协科技.assets\image-20240102194855903.png)

- 在主程序种查看和清除标志位用前两个函数，在中断函数中查看和清除标志位用后两个函数。后两个函数只能读取与中断有关的标志位，并且对中断是否允许做出了判断。
- 中断程序结束后，一定要调用清除中断标志位的函数，因为只要中断标志位置1程序就会跳到中断函数，如果不清除在中断标志位，那它就会一直申请中断：

![image-20240102201255565](stm32_江协科技.assets\image-20240102201255565.png)

- 最好不要在中断函数和主函数调用相同的函数或者操作同一个硬件，尤其是硬件相关的函数（比如OLED显示函数）。**在中断操作里操作变量或者标志位，当中断返回时再对这个变量进行显示和操作。**既能保证中断函数的简短快速，又能保证不产生冲突的硬件操作。

## [6-1]TIM定时中断

1. 定时器基本定时中断、内外时钟源选择
2. 定时器输出比较（产生PWM波形，用于驱动电机等设备）
3. 定时器输入捕获、主从触发模式
4. 定时器编码器接口

### 1.

16位计数器：用来执行计数定时的一个寄存器，每来一个时钟，计数器加1；

预分频器（16位）：对计数器时钟进行分频；

自动重装计时器（16位）：想要计多少个时钟申请中断；

这些寄存器构成了定时器最核心的部分，我们把这一块电路称为**时基单元**。

- **实际分频系数=预分频器的值+1**，预分频器时16位的，所以最大值可以写65535，也就是65536分频。对输入的基准频率提前进行分频操作。

- ![image-20240102215347355](stm32_江协科技.assets\image-20240102215347355.png)
- ![image-20240102215210812](stm32_江协科技.assets\image-20240102215210812.png)

​	计数值等于自动重装值产生的中断称为”**更新中断**“。更新中断之后就会通往NVIC，再配置好NVIC的定时器通道，那定时器的更新中断就能得到CPU的响应了。

​	向下的箭头代表会产生一个事件，这里对应的事件就叫做”**更新事件**“。更新事件不会触发中断，但可以触发内部其它电路的工作。

​	**主模式触发DAC实现硬件自动化，整个过程不需要软件的参与。**

- 关于三种定时器的计数模式：基本定时器只支持向上计数模式，通用定时器和高级定时器除了支持向上计数外还支持向下计数模式（从重装载寄存器向下自减，减到0回到重装值同同时申请中断）和中央对齐模式（先上到重装值申请中断，再向下自减到0申请中断）。

![image-20240102220438852](stm32_江协科技.assets\image-20240102220438852.png)

<center>三种计数方式的形象化说明</center>

**最常用的还是向上计数模式。**也是主要需要掌握的模式。

---

![image-20240104145043408](stm32_江协科技.assets/image-20240104145043408.png)

![image-20240102220719096](stm32_江协科技.assets\image-20240102220719096.png)

- 对于基本定时器而言，定时器只能选择内部时钟（也就是系统频率72MHz）。而对于通用定时器，不仅可以选择72MHz系统内部时钟，还可以选择外部时钟，具体有：来自TIMx_ETR引脚上（PA0）的外部时钟，滤波后的信号兵分两路，**ERTF又称作”外部时钟模式2“，TRGI又称作”外部时钟模式1“**。
- ITR0~3分别来自其他4个定时器的TRGO输出。通过这一路就可以实现定时器级联的功能。TI1F_ED表示通过这一路输入的时钟，上升沿和下降沿均有效。

总结一下就是，外部时钟模式1的输入可以是ETR引脚、其他定时器（ITR）、CH1引脚的边沿、CH1引脚和CH2引脚。一般情况下外部时钟通过ETR引脚就可以了。下面设置复杂的输入，不仅是为了扩大时钟的输入范围，更多还是为了某些特殊应用场景而设计的。比如为了定时器的级联而设计的ITR部分。对于时钟输入而言，最常用的还是内部的72MHz时钟。

对于高级定时器，主要改动的是右边的部分：

![image-20240104150922182](stm32_江协科技.assets/image-20240104150922182.png)

申请中断的地方增加了一个重复次数计数器，有了这个计数器以后，就可以实现每隔几个计数周期，才发生一次更新事件和更新中断，原来的结构式每个计数周期完成后都会发生中断，**相当于对输出的信号又做了一次分频**。

DTG（Dead Time Generate）是死区生成电路，为了防止互补输出的PWM驱动桥臂时在开关切换瞬间，由于器件不理想造成短暂的直通现象，所以前面就加上了死区生成电路，在开关切换瞬间，产生一定时长的死区，让桥臂的上下管全都关断，防止**直通现象**。右边的输出引脚由原来的一个变为了两个互补的输出，可以输出一对互补的PWM波。这些电路是为了驱动三相无刷电机的。三相无刷电机常用于四轴飞行器、电动车的后轮、电钻等。

![image-20240104153152256](stm32_江协科技.assets/image-20240104153152256.png)

最后一部分就是刹车输入的功能，给电机驱动提供安全保障。如果外部引脚BKIN（Break In）产生了刹车信号，或者内部时钟失效，产生了故障，那么控制电路就会自动切换电机的输出，防止意外发生。

![image-20240104153516376](stm32_江协科技.assets/image-20240104153516376.png)

中断信号会先在状态寄存器里置一个中断标志位，这个标志位会通过中断输出控制，到NVIC申请中断。为什么需要中断输出控制？因为这个定时器模块有很多地方都需要申请中断，不仅更新要申请中断，触发信号也会申请中断，还有下面的输入捕获和输出匹配时也会申请，所以这些中断都要经过中断输出控制，如果需要这个中断就允许，不需要就禁止。简单来说，这个中断输出控制就是一个中断输出的允许位，如果需要某个中断就记得允许一下。

* PPT58开始的时序图补充：预分频器为了防止计数中途更改数值造成错误，设计了缓冲寄存器，计数器也少不了这样的设计。**结构图中带黑色阴影的寄存器都是有影子寄存器这样的缓冲机制的**，包括预u分频器、自动重装寄存器（**ARR**）和下面的捕获比较寄存器。
* ARR的缓冲寄存器用与不用是可以自己设置的。计数器无预装时序就是没有缓冲寄存器的情况，有预装时序就是有缓冲寄存器的情况。**通过设置ARPE位，就可以选择是否使用预装功能。**引入影子寄存器的目的是为了同步，让值的变化和更新事件同步发生，防止在运行途中更改造成错误。

视频41：01讲了RCC时钟树相关内容。时钟是所有外设运行的基础，所以时钟也最先需要配置的东西。外部的石英振荡器（OSC，oscillator）比内部的RC振荡器更加稳定，所以一般都用外部晶振。

---

## [6-2]定时器定时中断和定时器外部时钟

- 因为定时器和中断系统的电路都在STM32内部，定时中断也是为程序设计提供服务的，所以芯片外面只插一个OLED显示数据就行了。

![image-20240104170909958](stm32_江协科技.assets/image-20240104170909958.png)

- 先在”Timer.c“文件中定时器进行初始化，创建`void Timer_Init(void)`函数。
  - RCC开启时钟，定时器基准时钟和整个外设的工作时钟就会同时打开了。
  - 选择时基单元的时钟源，这里选择RCC内部时钟。
  - 配置时基单元，这里用一个结构体就可以配置好了。
  - 配置输出中断控制，允许更新中断输出到NVIC。
  - 配置NVIC，在NVIC打开定时器中断的通道，并分配一个优先级。
  - **运行控制**，整个模块配置完后还需要使能一下计数器，不然计数器是不会运行的。

当定时器使能后，计数器就会开始计数了，当计数器更新时，触发中断；最后再写一个定时器的中断函数，这样这个中断函数每隔一段时间就能自动执行一次了。

> ![image-20240104172110795](stm32_江协科技.assets/image-20240104172110795.png)
>
> 左上角的小棋子🚩是用来插书签用的，不影响代码的运行。

`void TIM_Cmd(TIM_TypeDef* TIMx, FunctionalState NewState);`用来使能计数器（也就是与运行控制相关），第一个参数选择定时器，第二个选择状态（使能、失能）。

![image-20240104203640241](stm32_江协科技.assets/image-20240104203640241.png)

* 注意预分频器的值和自动重装寄存器的值要比实际系数分频系数与溢出系数小1，所以在确定溢出频率后（比如此代码设定1Hz，即1s溢出一次）后，二者都要在原参数上-1，两个参数的最大值均不超过65535，也就是0xFFFF）。

- 配置时基单元中TIM_ClockDivision一项是用来决定ETR/TIx的输入滤波器采样频率相对于内部时钟（CK_INT）的分频系数的。采样频率可以由CK_INT直接得来（就是直接是CK_INT），或者由CK_INT分频而来，采样频率越高，采样点数越多，滤波效果越好。可见这个参数和时基单元关系并不大。这里配置为DIV1，即不分频。

- 如果想跨文件使用变量，有两种方式：

  - [ ] 在使用变量的文件（区分于定义变量的文件）的上面用**extern**声明一下要用的变量（如下图所示）。全局变量不是编译器在找，而是在链接时，链接器会进行符号的解析和重定位，将定义处的地址给到引用全局变量的位置。

  ![image-20240104212001426](stm32_江协科技.assets/image-20240104212001426.png)

  其实头文件的函数声明也是用extern实现的，在声明的函数前是有一个extern的，只不过这个extern可以省略，所以我们一般不写。

  - [x] 直接把TIM2的中断函数放在主函数里。对于定时中断而言，中断函数就是为别的文件服务的，所以中断函数可以放在使用它的地方。

---

![image-20240104213243170](stm32_江协科技.assets/image-20240104213243170.png)

上图是复位后计数器值从1开始的原因，在`TIM_TimeBaseInit(TIM2, &TIM_TimeBaseInitStructure);`函数最后一行。因为预分频器是有缓冲寄存器的，我们写的值只有在更新事件时才会真正起作用
